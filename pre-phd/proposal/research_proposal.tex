\documentclass{article}
\usepackage[UKenglish]{babel}
\usepackage[UKenglish]{isodate}
\usepackage{amsmath}
\usepackage{fullpage}

\begin{document}
\title{Abstraction Algorithms for Probabilistic Relational Models}
\author{Paulius Dilkas}
\maketitle

\section{Introduction}

While the word `abstraction' can be associated with many different
processes that occur in our perception of the world, reasoning about it, or
representation in language, science, or art, it can be broadly thought of as the
process (and result) of omitting detail \cite{doi:10.1086/670300}. Sometimes the
omitted information is irrelevant in answering the questions we are interested
in, and sometimes an abstraction provides a simplified (and approximately
correct) view of a situation that originally was too complex to be reasoned
about.

% cognitive science
Abstraction is an important tool in human cognition and a well-studied subject
in cognitive science. For example, Gentner and Hoyos \cite{Gentner2017-GENAAA-2}
investigate how children learn abstract patterns from observing several
objects with a common property, while Bransford and Franks
\cite{BRANSFORD1971331} show how the idea conveyed by a sentence is abstracted
away from the particulars of its syntactic expression.

% AI
Abstraction is also well-known in the artificial intelligence (AI) community,
where the main goal of abstraction is to reduce the computational complexity of
a task, while ensuring that the process of abstraction itself is reasonably
efficient \cite{saitta2013abstraction}. For instance, abstraction plays a key
part in modern approaches to planning, where compound tasks are used to abstract
away the details of how the tasks can be implemented
\cite{DBLP:journals/amai/ErolHN96}. More specifically, abstraction is essential
in developing explainable AI \cite{DBLP:journals/access/AdadiB18}, where
it has been used to create interpretable abstractions of observed behaviour
\cite{DBLP:journals/corr/PenkovR17} and model the domain knowledge of the user
as an abstraction of the system, thus producing explanations that are at the
level of detail corresponding to the user's knowledge
\cite{DBLP:conf/ijcai/SreedharanSK18}.

% verification
Model checking and verification benefits from abstraction as well, particularly
in the area of software verification, where a complete model of the program
might be too big to be handled by even the most efficient methods. In such a
case, an abstract model could be developed. Depending on how it is created,
sometimes properties of the system can be verified using the abstraction
\cite{DBLP:journals/toplas/ClarkeGL94}, while other times the abstract model
might produce a false positive, i.e., signal about a possible problem where
there is none. If the occurrence of a false positive is suspected, parts of the
abstraction can be refined to provide the necessary level of detail, while
keeping other parts as they were
\cite{DBLP:conf/cav/ClarkeGJLV00,DBLP:conf/popl/HenzingerJMS02}.

% probabilities in programming
Note that few of the covered works on abstraction ever mention
probabilities or uncertainty---concepts crucial to AI. Probabilistic
abstractions have been used in the context of software verification, where
probabilities can help the verification algorithm choose which part of the
abstract model needs to be refined \cite{DBLP:conf/pldi/ZhangSN17}. Meanwhile,
in the probabilistic programming \cite{DBLP:conf/icse/GordonHNR14} community,
abstractions have been used to determine the required number of Monte Carlo
samples in order to compute a probability within a required level of precision
\cite{DBLP:conf/popl/Monniaux01}. However, only recently has the general case of
probabilistic program abstraction been formalised
\cite{DBLP:conf/uai/HoltzenMB17}. Abstraction in the context of probabilities is
an underexplored field, awaiting significant developments in both its theory and
practice.

\section{Proposed Research}

My proposed research is in abstraction for probabilistic relational models
(PRMs)---a collection of representations combining elements of
first-order logic with probabilistic graphical models
\cite{getoor2007introduction, heckerman2004probabilistic}. A prominent example
is a Markov logic network \cite{DBLP:journals/ml/RichardsonD06}, which is
simply a collection of statements expressed in first-order logic, with a weight
attached to each statement. While some theoretical groundwork for abstraction in
these models has recently been developed by Belle \cite{belle2018abstracting},
there are many questions left to be answered:
\begin{enumerate}
\item How to efficiently create an abstraction of an already-existing
  model? \label{q:1}
\item When is the correct time to stop? What is the right balance between
  simplicity and information? \label{q:2}
\item What makes one abstraction preferable to another? \label{q:3}
\item How to incorporate abstraction steps into learning a model from
  data? \label{q:4}
\item How to provide guarantees about an abstraction? For example, we may want
  to bound the error of an answer to any query, or to ensure that all answers
  remain exact for a selected set of queries. \label{q:5}
\end{enumerate}

In order to answer these questions and develop the required algorithms and
techniques, we can draw inspiration from the theory of abstraction for reasoning
in formal systems developed by Giunchiglia and Walsh
\cite{DBLP:journals/ai/GiunchigliaW92} and recent work on abstraction for
structural equation models \cite{DBLP:conf/uai/RubensteinWBMJG17}. In
particular, an abstraction is often defined as a transformation of the
representation into a different form. One way to create such a transformation is
via a composition of atomic operations. For example:
\begin{itemize}
\item In some cases, $a \implies b$ and $b \implies c$ can be simplified to $a
  \implies c$.
\item If a statement $S$ is true with high probability, perhaps that probability
  can be rounded up to $1$, eliminating the need to consider the case where $S$
  is false.
\item If a statement is true for all values of a variable, barring a few
  exceptions, perhaps the exceptions can be discarded.
\end{itemize}
Consider a specific query $Q$. Applying such an abstraction rule may or may not
change the answer to $Q$, depending on whether the removed information
is relevant to the query. Even if the answer becomes less precise, it might be
an acceptable approximation, given that the error is bounded to a reasonable
degree. Either way, the abstraction can reduce the search space the inference
algorithm has to explore in order to produce an answer.

It becomes clear that it is important to consider creating an abstraction w.r.t.
a specific set of queries. Question \ref{q:5} can then be answered by
considering how each abstraction rule affects different types of queries.
Sometimes we may get a reasonable numerical upper bound on the error, while
other times it may be too time-consuming (or impossible) to bound the error to
any reasonable degree, forcing us to reject the abstraction rule altogether.

Questions \ref{q:2} and \ref{q:3} delve deeper into how an abstraction algorithm
could work. If the set of rules is extensive enough, any model might
eventually be oversimplified into something trivial. We need to measure two
things: the amount of (relevant) information preserved by an abstraction, and
the complexity of the model. The two metrics would provide a systematic way to
answer both questions, while being easily adaptable to different needs (e.g.,
how much precision are we willing to sacrifice? what queries do we want to
support?).

\section{Conclusion}

As abstraction for expressive probabilistic models such as PRMs and
probabilistic programs has only been defined quite recently
\cite{belle2018abstracting,DBLP:conf/uai/HoltzenMB17}, this is the perfect time
to explore the possibilities and benefits of an old idea applied to modern
models for probabilistic inference and reasoning. Simplification and abstraction
can benefit us in both efficiency and interpretability, i.e, simpler models are
likely to result in faster inference, while at the same time being easier to
understand by the user. Finally, the quest for abstraction algorithms is likely
to lead to a better theoretical understanding of what properties can be
preserved by an abstraction, what error bounds can be established when
abstraction approximates the answer, and upper and lower bounds on the
complexity of performing abstraction and providing the desired guarantees.

\bibliographystyle{plain}
\bibliography{proposal}
\end{document}