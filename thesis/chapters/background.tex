% 11-45 pages (27 on average)
% aim for 2-5 pages for each major section
\chapter{Background}

TODO: outside of specific sections, have a one-paragraph introduction before and a one-paragraph summary at the end.

\section{Logic}

(Boolean) operators:
\begin{description}
\item[negation] $\neg$
\item[disjunction] $\lor$
\item[conjunction] $\land$
\item[(material) implication] $\Rightarrow$
\item[equivalence (material biconditional)] $\Leftrightarrow$
\end{description}

formula - another word for expression

a formula is \emph{satisfiable} if some interpretation is true (i.e., it has at least one model)

Throughout the thesis, we use set-theoretic notation for many concepts in logic.

A \emph{clause} is a set of literals that are part of an implicit disjunction.

Similarly, a \emph{formula} in CNF is a set of clauses that are part of an implicit conjunction.

We identify a \emph{model} with a set of variables that correspond to the positive literals in the model (and all other variables are the negative literals of the model).

We can then define the \emph{cardinality} of a model as the cardinality of this set.

For example, let $\phi = (\neg a \lor b) \land a$ be a propositional formula over variables $a$ and $b$.

Then an equivalent set-theoretic representation of $\phi$ is $\{ \{\neg a, b \}, \{ a \} \}$.

Any subset of $\{ a, b \}$ is an interpretation of $\phi$, e.g., $\{ a, b \}$ is a model of $\phi$ (written $\{ a, b \} \models \phi$) of cardinality two, while $\emptyset$ is an interpretation but not a model.

`atomic proposition (atom for short)'

[interpretations] `assign one of the (truth) values to every atomic proposition'

The basic primitives of logic programs are \emph{constants}, \emph{(logic) variables}, and \emph{predicates} with their \emph{arities}.

A \emph{term} is either a variable or a constant, and an \emph{atom} is a predicate of arity $n$ applied to $n$ terms.

A \emph{formula} is any well-formed expression that connects atoms using conjunction $\land$, disjunction $\lor$, and negation $\neg$.

By \emph{variable}, we always mean a Boolean variable.

A \emph{literal} is
either a variable (say, $v$) or its negation (denoted $\neg v$), respectively
called \emph{positive} and \emph{negative} literal.

`A \emph{literal} is an atom or or the negation of an atom. An atom is a \emph{positive literal}, and the negation of an atom is a \emph{negative literal}.'

A \emph{clause} is a
disjunction of literals.

A \emph{formula} is any well-formed expression consisting of variables, negation, conjunction, and disjunction.

A formula is in \emph{conjunctive normal form} (CNF) if it is a conjunction of clauses, and it is in $k$-CNF if every clause has exactly $k$ literals.

While we use the set-theoretic notation for CNF formulas (e.g., writing $c \in \phi$ to mean that clause $c$ is one of the clauses in formula $\phi$), duplicate clauses are still allowed.

\begin{itemize}
\item (Boolean) variable
\item notation for connectives: conjunction, disjunction, negation, material implication, material biconditional
\item literal
\item clause (note that \cref{chapter:randomlps} defines it differently)
\item (well-formed) formula
\item CNF (many other normal forms and ways to represent propositional formulas are covered in \cref{sec:kc})
\item interpretation
\item model
\item TODO (later): applications of logic in computer science: planning, logical inference, verification, scheduling, etc. (Section 2.1 of Guy's thesis)
\item more on logic: \citep{DBLP:books/daglib/0029942}
\end{itemize}

\subsection{First-Order Logic}

\begin{itemize}
\item function-free throughout
\item equality
\item predicate, arity
\item atom, how atoms replace variables
\item constant
\item variables
\item term: variable or constant
\item domain (of discourse). always consider finite domains (as in Guy's thesis, Friedman et al. 1999, Richardson and Domingos 2006). This makes, e.g., satisfiability decidable and a FO formula can always be extended to a propositional one.
\item existential, universal quantification
\item ground (atom, etc.)
\item citations from page 41 of Guy's thesis
\item more on first-order logic: \citep{DBLP:books/daglib/0023546}
\end{itemize}

\subsection{Logic-Based Computational Problems}

\begin{itemize}
\item \SAT{} (book: \citep{DBLP:series/faia/2009-185}, intro and history: \citep{DBLP:series/faia/FrancoM09})
\item counting
  \begin{itemize}
  \item MC (\#\SAT{}) \citep{DBLP:series/faia/GomesSS09}
  \item WMC \citep{DBLP:journals/ai/ChaviraD08}
  \item PMC ($\#\exists\SAT{}$) \citep{DBLP:conf/sat/AzizCMS15}
  \item (SW)FOMC \citep{DBLP:conf/ijcai/BroeckTMDR11}
  \end{itemize}
\item Max\SAT{} \citep{bacchus2021maximum,DBLP:series/faia/LiM09}
\item QBF \citep{DBLP:series/faia/BuningB09}. Applications: \citep{DBLP:conf/ictai/ShuklaBPS19}
\item Also briefly mention:
  \begin{itemize}
  \item PB \citep{DBLP:series/faia/RousselM09}
  \item SMT \citep{DBLP:series/faia/BarrettSST09}
  \item CP \citep{DBLP:reference/fai/2} (forward reference to \cref{sec:cp,chapter:randomlps})
  \item IP \citep{wolsey2020integer}.
  \end{itemize}
\end{itemize}

\section{Some Declarative Programming Paradigms}

\begin{itemize}
\item Logic Programming (with a forward reference to probabilistic logic programming)
  \begin{itemize}
  \item Maybe: Stratification
  \end{itemize}
\item Constraint Programming (and why it's useful to have constraint models)
  \begin{itemize}
  \item Maybe: Search and Heuristics
  \item Maybe: Symmetry Breaking
  \item Maybe: Propagation and Entailment
  \end{itemize}
\end{itemize}

\subsection{Logic Programming}

\subsection{Constraint Programming} \label{sec:cp}

\section{Representations of Probability Distributions}

(including the ideas behind inference)
\begin{itemize}
\item Probabilistic Graphical Models
  \begin{itemize}
  \item Bayesian Networks
  \item Markov Random Fields
  \item Relational
    \begin{itemize}
    \item Markov Logic Networks
    \end{itemize}
  \end{itemize}
\item Probabilistic Programming
  \begin{itemize}
  \item Imperative and (Maybe) Functional, e.g., BLOG
  \item Probabilistic Logic Programming
    \begin{itemize}
    \item ProbLog (including some detail about how inference is defined)
    \end{itemize}
  \end{itemize}
\end{itemize}

\section{Knowledge Compilation} \label{sec:kc}

(including lots of detail about all the data structures)
\begin{itemize}
\item Boolean and Pseudo-Boolean Functions
\item NNF
\item d-DNNF
\item SDDs
\item BDDs
\item ADDs (with a brief mention of AADDs, XDDs, etc.)
\end{itemize}

\section{Applications}

\begin{itemize}
\item Statistical Relational Learning
\item Neuro-Symbolic Artificial Intelligence
\item Natural Language Processing
\item Robotics
\end{itemize}
