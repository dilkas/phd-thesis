% 11-45 pages (27 on average)
% aim for 2-5 pages for each major section
\chapter{Background}

TODO: outside of specific sections, have a one-paragraph introduction before and a one-paragraph summary at the end.

\section{Logic}

TODO: update this description

This section describes the terminology of formal logic that is used throughout the thesis. We begin with propositional logic, then cover first-order logic in \cref{sec:fologic} and logic-based computational problems and their applications in \cref{sec:logicproblems}. See the book by \cite{DBLP:books/daglib/0029942} for a more detailed introduction to logic in the context of computer science.

An \emph{atomic proposition} (\emph{atom} for short) is a Boolean/logical variable with two possible \emph{truth} values: true and false. Unless specified otherwise, we will refer to atoms as \emph{variables}. A \emph{formula} is any well-formed expression that connects variables using the following Boolean/logical operators (and parentheses): negation ($\neg$), disjunction ($\lor$), conjunction ($\land$), (material) implication ($\Rightarrow$), and equivalence (i.e., material biconditional) ($\Leftrightarrow$). A \emph{literal} is either a variable or its negation, respectively called \emph{positive} and \emph{negative} literal. A \emph{clause} is a disjunction of literals.\footnote{In the context of logic programs, the word \emph{clause} is used differently (see \cref{sec:lp,chapter:randomlps}).} A formula is in \emph{conjunctive normal form} (CNF) if it is a conjunction of clauses, and it is in $k$-CNF if every clause has exactly $k$ literals. Many other normal forms and ways to represent propositional formulas are covered in \cref{sec:kc}.

An \emph{interpretation} of a formula $\phi$ is a map from the variables of $\phi$ to the set $\{\, \text{true}, \text{false} \,\}$. A \emph{model} is an interpretation under which $\phi$ evaluates to true. A formula is \emph{satisfiable} if it has at least one model.

Throughout the thesis, we use set-theoretic notation for many concepts in logic such as clauses and formulas in CNF (e.g., we write $c \in \phi$ to mean that clause $c$ is one of the clauses of formula $\phi$). However, this does not automatically mean that we assume no duplicates---whether or not that is the case is clarified on a case-by-case basis.

\begin{example}
  Formula $\phi \coloneqq (\neg a \lor b) \land a$ has two variables $a$ and $b$, is in CNF, and contains two clauses. The first clause $\neg a \lor b$ has a negative literal $\neg a$ and a positive literal $b$. Since $\phi$ has two variables, it also has four interpretations. Interpretation $\{\, a \mapsto \text{true}, b \mapsto \text{true} \,\}$ is a model, so $\phi$ is satisfiable. An equivalent set-theoretic representation of $\phi$ is $\{\, \{\, \neg a, b \,\}, \{\, a \,\} \,\}$.
\end{example}

\subsection{Logic-Based Computational Problems} \label{sec:logicproblems}

\begin{itemize}
\item \SAT{} (book: \citep{DBLP:series/faia/2009-185}, intro and history: \citep{DBLP:series/faia/FrancoM09})
\item counting
  \begin{itemize}
  \item MC (\#\SAT{}) \citep{DBLP:series/faia/GomesSS09}
  \item WMC \citep{DBLP:journals/ai/ChaviraD08}
  \item PMC ($\#\exists\SAT{}$) \citep{DBLP:conf/sat/AzizCMS15}
  \item (SW)FOMC \citep{DBLP:conf/ijcai/BroeckTMDR11}
  \end{itemize}
\item Max\SAT{} \citep{bacchus2021maximum,DBLP:series/faia/LiM09}
\item QBF \citep{DBLP:series/faia/BuningB09}. Applications: \citep{DBLP:conf/ictai/ShuklaBPS19}
\item Also briefly mention:
  \begin{itemize}
  \item PB \citep{DBLP:series/faia/RousselM09}
  \item SMT \citep{DBLP:series/faia/BarrettSST09}
  \item CP \citep{DBLP:reference/fai/2} (forward reference to \cref{sec:cp,chapter:randomlps})
  \item IP \citep{wolsey2020integer}.
  \end{itemize}
\item applications of logic in computer science: planning, logical inference, verification, scheduling, etc. (Section 2.1 of Guy's thesis)
\end{itemize}

\section{Some Declarative Programming Paradigms}

\begin{itemize}
\item Logic Programming (with a forward reference to probabilistic logic programming)
  \begin{itemize}
  \item Maybe: Stratification
  \end{itemize}
\item Constraint Programming (and why it's useful to have constraint models)
  \begin{itemize}
  \item Maybe: Search and Heuristics
  \item Maybe: Symmetry Breaking
  \item Maybe: Propagation and Entailment
  \end{itemize}
\end{itemize}

\subsection{Logic Programming} \label{sec:lp}

\subsection{Constraint Programming} \label{sec:cp}

\section{Representations of Probability Distributions}

(including the ideas behind inference)
\begin{itemize}
\item Probabilistic Graphical Models
  \begin{itemize}
  \item Bayesian Networks
  \item Markov Random Fields
  \item Relational
    \begin{itemize}
    \item Markov Logic Networks
    \end{itemize}
  \end{itemize}
\item Probabilistic Programming
  \begin{itemize}
  \item Imperative and (Maybe) Functional, e.g., BLOG
  \item Probabilistic Logic Programming
    \begin{itemize}
    \item ProbLog (including some detail about how inference is defined)
    \end{itemize}
  \end{itemize}
\end{itemize}

\section{Knowledge Compilation} \label{sec:kc}

(including lots of detail about all the data structures)
\begin{itemize}
\item Boolean and Pseudo-Boolean Functions
\item NNF
\item d-DNNF
\item SDDs
\item BDDs
\item ADDs (with a brief mention of AADDs, XDDs, etc.)
\end{itemize}

\section{Applications}

\begin{itemize}
\item Statistical Relational Learning
\item Neuro-Symbolic Artificial Intelligence
\item Natural Language Processing
\item Robotics
\end{itemize}
